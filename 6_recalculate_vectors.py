#! /usr/bin/env python
## imports

## Finds the average unit cell vector using eth refined spots generated by the first four setps
## in these programs.

# Matt Iadanza 20-07-05

import os
import math
import numpy
import json
import datetime

#### user input variables



####  some user entered varibales
## thresholds or finding parallel vectors waht % of the starting vector?

pthresh = 0.15

#### get yer data:
data = json.load(open('cataspot.json'))
numberofimages = len(data["data"]["images"])
params = json.load(open('params.json'))
imgsize = params['imgsize']
maxres = params['imgmaxres']
avec = numpy.array(params["aucvec"])
bvec = numpy.array(params["bucvec"])
cvec = numpy.array(params["cucvec"])





#### init and version check
os.system('clear')
vers = 1
catspotvers = data["metadata"]["file version"]
print "** Unit Cell Vector Determination vers %s **" % round(vers,2)
if vers != catspotvers:
    print "datafile version mismatch %s/%s - may cause errors" % (round(vers,2),round(catspotvers,2))
else:
    print "version check -- passed"

##### do it

print ""
print "make the spolist dictionarys"
with open('imagelist.txt') as f:
    images2process = f.read().splitlines()
with open('refined.txt') as spotfile:
    allspots = spotfile.read().splitlines()

### calculate 3-D coordinates for each spot

##------- ewald sphere correction (z dimension) function----------
def ewaldcorr(xdim,ydim):
    wavelength = 0.025
    oneoverlambda = 1/(wavelength * (1/(0.5 * imgsize * maxres)))
    a = oneoverlambda/math.sqrt(xdim**2+ydim**2+oneoverlambda**2)
    deltaz = (1-a)*oneoverlambda
    return deltaz
##-----------------------------------------------------------------


spotlist = []
for eachspot in allspots:
    i = eachspot.split('\t')    
    theta = float(i[2])
    ox = float(i[0])
    oy = float(i[1])
    x = ox - data["data"]["images"][i[3]]["beamcenter"][0][0]
    y = -(oy - data["data"]["images"][i[3]]["beamcenter"][0][1])*math.cos(theta*math.pi/180.0)
    z = -(oy - data["data"]["images"][i[3]]["beamcenter"][0][1])*math.sin(theta*math.pi/180.0) - ewaldcorr(x,y)
    spotlist.append(numpy.array([x,y,z]))
    

### open logfile
logout = open("logfile.txt", "a")
now = datetime.datetime.now()
logout.write("\n6_recalculate_vectors \t%s\t%s spots\n" % (now.strftime("%Y-%m-%d %H:%M"),len(spotlist)))
logout.write("threshold: %s\n" % pthresh)
logout.write("old vectors:\n")
logout.write("a: %s\t b: %s\t c:%s\n" % (avec,bvec,cvec))
print "build spotlist: %s spots picked" % len(spotlist)



#### calculate difference vectors and compare to the reference vectors: 
print"subtract every vector from every other and determine the magnitude of results - keep possible unit cell vectors\n"

diffvecs = []
for n in spotlist:
    for i in spotlist:
        diffvecs.append(numpy.subtract(n,i))
        
poavs = []
pobvs = []
pocvs = []

## calculate thresholds

ax= abs(avec[0]*pthresh)
ay= abs(avec[1]*pthresh)
az= abs(avec[2]*pthresh)
bx= abs(bvec[0]*pthresh)
by= abs(bvec[1]*pthresh)
bz= abs(bvec[2]*pthresh)
cx= abs(cvec[0]*pthresh)
cy= abs(cvec[1]*pthresh)
cz= abs(cvec[2]*pthresh)

##for debug
#print ax,ay,az,bx,by,bz,cx,cy,cz


for i in diffvecs:
    if abs(avec[0] - i[0]) < ax and abs(avec[1] - i[1]) < ay and abs(avec[2] - i[2]) < az:
        poavs.append(i)
    if abs(bvec[0] - i[0]) < bx and abs(bvec[1] - i[1]) < by and abs(bvec[2] - i[2]) < bz:
        pobvs.append(i)
    if abs(cvec[0] - i[0]) < cx and abs(cvec[1] - i[1]) < cy and abs(cvec[2] - i[2]) < cz:
        pocvs.append(i)
print "# of contributing vectors: a: %s\t b:%s\t c:%s" % (len(poavs),len(pobvs),len(pocvs))
   
##----------- function to calculate the angle betwen two vectors ----------

def calcang(a,b):
    v12 = numpy.dot(a,b)
    v1mag = numpy.linalg.norm(a)
    v2mag = numpy.linalg.norm(b)
    cosphi = abs((v12)/(v1mag*v2mag))
    return round((180/math.pi)*math.acos(round(cosphi,12)),0)
##-------------------------------------------------------------------------

##----------- function to calculate the angle betwen two vectors - nonabsoulte ----------

def calcangnonabs(a,b):
    v12 = numpy.dot(a,b)
    v1mag = numpy.linalg.norm(a)
    v2mag = numpy.linalg.norm(b)
    cosphi = ((v12)/(v1mag*v2mag))
    return round((180/math.pi)*math.acos(round(cosphi,12)),0)
##-------------------------------------------------------------------------

##--------- funct to calculate mean vectors -----------------
def vecmean(x):
    if len(x) > 0:
        iss = []
        js = []
        ks = []
        for i in x:
            iss.append(i[0])
            js.append(i[1])
            ks.append(i[2])
        mean = numpy.array([numpy.mean(iss),numpy.mean(js),numpy.mean(ks)])
        return [mean, numpy.linalg.norm(mean)]
    else:
        return ["no vector","n/a"]
##----------------------------------------------------------

##### claculate the mean vectors and the angles between them
a = vecmean(poavs)[0]
b = vecmean(pobvs)[0]
c = vecmean(pocvs)[0]

print"\nvector calculations:"
print "old:\t%s\t%s\t%s" % (avec,bvec,cvec)
print "new:\t%s\t%s\t%s" % (vecmean(poavs)[0],vecmean(pobvs)[0],vecmean(pocvs)[0])
logout.write("new vectors:\n")
logout.write("a: %s\t b: %s\t c:%s\n\n" % (a,b,c))
